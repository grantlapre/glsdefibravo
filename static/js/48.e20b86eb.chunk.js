(self.webpackChunkglsdefib=self.webpackChunkglsdefib||[]).push([[48],{70028:(i,n,t)=>{"use strict";t.d(n,{OpenloginAdapter:()=>p,getOpenloginDefaultOptions:()=>h});var e=t(20832),o=t(93880),s=t(52536),a=t(80572),r=t(94948),c=t.n(r);const h=(i,n)=>({adapterSettings:{network:e.aY.MAINNET,clientId:"",uxMode:e.mi.POPUP},chainConfig:i?(0,o.wh)(i,n):null,loginSettings:{}});function l(i,n){var t=Object.keys(i);if(Object.getOwnPropertySymbols){var e=Object.getOwnPropertySymbols(i);n&&(e=e.filter((function(n){return Object.getOwnPropertyDescriptor(i,n).enumerable}))),t.push.apply(t,e)}return t}function g(i){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){(0,s.c)(i,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(i,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(i,n,Object.getOwnPropertyDescriptor(t,n))}))}return i}class p extends o.Gt{constructor(i){var n,t,a;super(),(0,s.c)(this,"name",o.W2.OPENLOGIN),(0,s.c)(this,"adapterNamespace",o.Kg.MULTICHAIN),(0,s.c)(this,"type",o.oJ.IN_APP),(0,s.c)(this,"openloginInstance",null),(0,s.c)(this,"status",o.Uz.NOT_READY),(0,s.c)(this,"currentChainNamespace",o.Mj.EIP155),(0,s.c)(this,"openloginOptions",void 0),(0,s.c)(this,"loginSettings",{}),(0,s.c)(this,"privKeyProvider",null),o.Yz.debug("const openlogin adapter",i);const r=h(null===(n=i.chainConfig)||void 0===n?void 0:n.chainNamespace,null===(t=i.chainConfig)||void 0===t?void 0:t.chainId);if(this.openloginOptions=g(g({clientId:"",network:e.aY.MAINNET},r.adapterSettings),i.adapterSettings||{}),this.loginSettings=g(g({},r.loginSettings),i.loginSettings),this.sessionTime=this.loginSettings.sessionTime||86400,null!==(a=i.chainConfig)&&void 0!==a&&a.chainNamespace){var c;this.currentChainNamespace=null===(c=i.chainConfig)||void 0===c?void 0:c.chainNamespace;const n=r.chainConfig?r.chainConfig:{};if(this.chainConfig=g(g({},n),null===i||void 0===i?void 0:i.chainConfig),o.Yz.debug("const openlogin chainConfig",this.chainConfig),!this.chainConfig.rpcTarget&&i.chainConfig.chainNamespace!==o.Mj.OTHER)throw o.EF.invalidParams("rpcTarget is required in chainConfig")}}get chainConfigProxy(){return this.chainConfig?g({},this.chainConfig):null}get provider(){var i;return(null===(i=this.privKeyProvider)||void 0===i?void 0:i.provider)||null}set provider(i){throw new Error("Not implemented")}async init(i){var n;if(super.checkInitializationRequirements(),null===(n=this.openloginOptions)||void 0===n||!n.clientId)throw o.EF.invalidParams("clientId is required before openlogin's initialization");if(!this.chainConfig)throw o.EF.invalidParams("chainConfig is required before initialization");let t=!1;if(this.openloginOptions.uxMode===e.mi.REDIRECT){const i=(0,e.I3)();Object.keys(i).length>0&&i._pid&&(t=!0)}this.openloginOptions=g(g({},this.openloginOptions),{},{replaceUrlOnRedirect:t}),this.openloginInstance=new e.cp(this.openloginOptions),o.Yz.debug("initializing openlogin adapter init"),await this.openloginInstance.init(),this.status=o.Uz.READY,this.emit(o.Sc.READY,o.W2.OPENLOGIN);try{o.Yz.debug("initializing openlogin adapter"),this.openloginInstance.privKey&&(i.autoConnect||t)&&await this.connect()}catch(s){o.Yz.error("Failed to connect with cached openlogin provider",s),this.emit("ERRORED",s)}}async connect(i){super.checkConnectionRequirements(),this.status=o.Uz.CONNECTING,this.emit(o.Sc.CONNECTING,g(g({},i),{},{adapter:o.W2.OPENLOGIN}));try{return await this.connectWithProvider(i),this.provider}catch(n){if(o.Yz.error("Failed to connect with openlogin provider",n),this.status=o.Uz.READY,this.emit(o.Sc.ERRORED,n),null!==n&&void 0!==n&&n.message.includes("user closed popup"))throw o.kC.popupClosed();throw o.kC.connectionError("Failed to login with openlogin")}}async disconnect(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};if(this.status!==o.Uz.CONNECTED)throw o.kC.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw o.EF.notReady("openloginInstance is not ready");await this.openloginInstance.logout(),i.cleanup?(this.status=o.Uz.NOT_READY,this.openloginInstance=null,this.privKeyProvider=null):this.status=o.Uz.READY,this.emit(o.Sc.DISCONNECTED)}async authenticateUser(){if(this.status!==o.Uz.CONNECTED)throw o.kC.notConnectedError("Not connected with wallet, Please login/connect first");return{idToken:(await this.getUserInfo()).idToken}}async getUserInfo(){if(this.status!==o.Uz.CONNECTED)throw o.kC.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw o.EF.notReady("openloginInstance is not ready");return await this.openloginInstance.getUserInfo()}setAdapterSettings(i){if(this.status===o.Uz.READY)return;const n=h();this.openloginOptions=g(g(g({},n.adapterSettings),this.openloginOptions||{}),i),i.sessionTime&&(this.loginSettings=g(g({},this.loginSettings),{},{sessionTime:i.sessionTime}))}setChainConfig(i){super.setChainConfig(i),this.currentChainNamespace=i.chainNamespace}async connectWithProvider(i){if(!this.chainConfig)throw o.EF.invalidParams("chainConfig is required before initialization");if(!this.openloginInstance)throw o.EF.notReady("openloginInstance is not ready");if(this.currentChainNamespace===o.Mj.SOLANA){const{SolanaPrivateKeyProvider:i}=await Promise.all([t.e(888),t.e(248),t.e(854)]).then(t.bind(t,84248));this.privKeyProvider=new i({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===o.Mj.EIP155){const{EthereumPrivateKeyProvider:i}=await Promise.all([t.e(996),t.e(912)]).then(t.bind(t,42996));this.privKeyProvider=new i({config:{chainConfig:this.chainConfig}})}else{if(this.currentChainNamespace!==o.Mj.OTHER)throw new Error("Invalid chainNamespace: ".concat(this.currentChainNamespace," found while connecting to wallet"));this.privKeyProvider=new a.Sk}var n;!this.openloginInstance.privKey&&i&&(this.loginSettings.curve||(this.loginSettings.curve=this.currentChainNamespace===o.Mj.SOLANA?e.K4.ED25519:e.K4.SECP256K1),await this.openloginInstance.login(c()(this.loginSettings,{loginProvider:i.loginProvider},{extraLoginOptions:g(g({},i.extraLoginOptions||{}),{},{login_hint:i.login_hint||(null===(n=i.extraLoginOptions)||void 0===n?void 0:n.login_hint)})})));let s=this.openloginInstance.privKey;if(s){if(this.currentChainNamespace===o.Mj.SOLANA){const{getED25519Key:i}=await Promise.all([t.e(888),t.e(680)]).then(t.bind(t,92432));s=i(s).sk.toString("hex")}await this.privKeyProvider.setupProvider(s),this.status=o.Uz.CONNECTED,this.emit(o.Sc.CONNECTED,{adapter:o.W2.OPENLOGIN,reconnected:!i})}}}},16204:()=>{}}]);